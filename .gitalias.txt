# -*- mode: gitconfig; -*-
# vim: set filetype=gitconfig:
# ## Usage
#
# Typical usage for a typical user:
#
#   * Save this file as a dot file in your home directory: `~/.gitalias.txt`
#
#   * Edit your git config dot file in your home directory such as  `~/.gitconfig`
#
#   * Include the path to this file.
#
# Example file `~/.gitconfig` with an entry to include the file `~/.gitalias.txt`:
#
#     [include]
#       path = gitalias.txt
#
#
# ## Usage for older git versions
#
# If you use an older version of git that does not have git config "include" capability,
# or if you prefer more control, then you can simply copy/paste anything you like from
# this file to your own git config file.
#

[alias]

  ##
  # One letter alias for our most frequent commands.
  #
  # Guidelines: these aliases do not use options, because we want
  # these aliases to be easy to compose and use in many ways.
  ##

  a = add
  b = branch
  c = commit
  d = diff
  f = fetch
  g = grep
  l = log
  m = merge
  o = checkout
  p = pull
  r = remote
  s = status
  w = whatchanged

  # add all
  aa = add --all

  ### branch ###

  recent = "!f() { git reflog | egrep -io 'moving from ([^[:space:]]+)' | awk '{ print $3 }' | awk ' !x[$0]++' | head -n${1-15}; }; f"

  # branch description
  bd = !"git config branch.$(git rev-parse --abbrev-ref HEAD 2>/dev/null).description"

  # branch - edit the description
  be = branch --edit-description

  # branch and only list branches whose tips are reachable from the specified commit (HEAD if not specified).
  bm = branch --merged

  # branch and only list branches whose tips are not reachable from the specified commit (HEAD if not specified).
  bnm = branch --no-merged

  ### commit ###

  # commit - amend the tip of the current branch rather than creating a new commit.
  ca = commit --amend

  # commit - amend the tip of the current branch, and edit the message.
  cam = commit --amend --message

  # commit - add all and amend the tip of the current branch, and do not edit the message.
  aacane = commit -a --amend --no-edit

  # commit - amend the tip of the current branch, and do not edit the message.
  cane = commit --amend --no-edit

  # commit interactive
  ci = commit --interactive

  # commit with a message
  cm = commit --message

  ### checkout ###

  # checkout - update the working tree to match a branch or paths. [same as "o" for "out"]
  co = checkout

  ### cherry-pick ###

  # cherry-pick - apply the changes introduced by some existing commits; useful for moving small chunks of code between branches.
  cp = cherry-pick

  # cherry-pick - abort the picking process
  cpa = cherry-pick --abort

  # cherry-pick - continue the picking process
  cpc = cherry-pick --continue

  # cherry-pick without making a commit, and when when recording the commit, append a line that says "(cherry picked from commit ...)"
  cp-nx = cherry-pick --no-commit -x

  ### diff ###

  # diff - show changes not yet staged
  dc = diff --cached

  # diff - show changes about to be commited
  ds = diff --staged

  # diff - show changes but by word, not line
  dw = diff --word-diff

  # diff deep - show changes with our preferred options. Also aliased as `diff-deep`.
  dd = diff --check --dirstat --find-copies --find-renames --histogram --color

  ### clean ###

  # clean everything to be pristine
  cleanest = clean -ffdx

  ### grep ###

  # grep i.e. search for text
  g = grep

  # grep - show line number
  gl = grep --line-number

  # grep group - search with our preferred options. Also aliased as `grep-group`.
  gg = grep --break --heading --line-number --color

  ### log ###

  # log with a text-based graphical representation of the commit history.
  lg = log --graph

  # log with one line per item.
  lo = log --oneline

  # log with patch generation.
  lp = log --patch

  # log like - we like this summarization our key performance indicators. Also aliased as `log-like`.
  ll = log --graph --topo-order --date=short --abbrev-commit --decorate --all --boundary --pretty=format:'%Cgreen%ad %Cred%h%Creset -%C(yellow)%d%Creset %s %Cblue[%cn]%Creset %Cblue%G?%Creset'

  ## ls-files ##

  # ls-files - show information about files in the index and the working tree; like Unix "ls" command.
  ls = ls-files

  # ls-ignored -  list files that git has ignored.
  ls-ignored = ls-files --others --i --exclude-standard

  ### pull ###

  # pull if a merge can be resolved as a fast-forward, otherwise fail.
  pf = pull --ff-only

  # pull with rebase - to provide a cleaner, linear, bisectable history.
  #
  # To automatically do "pull --rebase" everywhere:
  #
  #     git config --global pull.rebase true
  #
  # To automatically do "pull --rebase" for any branch based on master:
  #
  #    git config branch.master.rebase true
  #
  # To automatically do "pull --rebase" for any newly-created branches:
  #
  #     git config --global branch.autosetuprebase always
  #
  # To integrate changes between branches, you can merge or rebase.
  #
  # When we use "git pull", git does a fetch then a merge.
  # If we've made changes locally and someone else has pushed changes
  # to our git host then git will automatically merge these together
  # and create a merge commit that looks like this in the history:
  #
  #    12345678 - Merge branch 'foo' of bar into master
  #
  # When we use "git pull --rebase", git does a fetch then a rebase.
  # A rebase resets the HEAD of your local branch to be the same as
  # the remote HEAD, then replays your local commits back into repo.
  # This means you don't get any noisy merge messages in your history.
  # This gives us a linear history, and also helps with git bisect.
  #
  pr = pull --rebase

  # pp - pull with rebase preserve of merge commits
  #
  # See https://stackoverflow.com/questions/21364636/git-pull-rebase-preserve-merges
  #
  # You should only rebase if you know (in a sort of general sense)
  # what you are doing, and if you do know what you are doing, then you
  # would probably prefer a merge-preserving rebase as a general rule.
  #
  # Although by the time you've decided that rebasing is a good idea,
  # you will probably find that a history that has its own embedded
  # branch-and-merge-points is not necessarily the correct "final
  # rewritten history".
  #
  # That is, if it's appropriate to do a rebase at all, it's at least fairly
  # likely that the history to be rebased is itself linear, so that the
  # preserve-vs-flatten question is moot anyway.
  #
  # See https://stackoverflow.com/questions/38269092/is-it-possible-to-put-preserve-merges-in-the-gitconfig
  #
  # While preserving merges is probably generally superior, in at least a
  # few ways, to discarding them when rebasing, the fact is that rebase
  # cannot preserve them. The only thing it can do, once some commits
  # have been copied to new commits, is re-perform them. This can have new
  # and/or different merge conflicts, vs the last time the merge was done.
  # You should also pay close attention to the restrictions on merge
  # preservation in the git rebase documentation.
  #
  # Without getting into a lot of detail, it always seems to me that most
  # commit graph subsets that "should be" rebased, rarely have any
  # internal merges. If such a graph subset has a single final merge, you
  # can simply strip away that merge (with git reset) before rebasing,
  # and re-do that single merge manually at the end. (In fact, git rebase
  # normally drops merge commits entirely, so you don't have to run the git
  # reset itself in some cases. The one where you do have to run it is when
  # the merge is into the branch onto which you intend to rebase. This is
  # where git pull actually does the right thing when it uses
  # `git rebase -p`, except that it fails to check for, and warn about,
  # internal merges, which are sort of warning signs that rebasing might
  # not be a good idea.
  #
  pp = pull --rebase=preserve

  ### rebase ###

  # rebase - forward-port local commits to the updated upstream head.
  rb = rebase

  # rebase on top of master (automatically pulls)
  rbm = "!f() { git co master; git pull; git co -; git rebase master; }; f"

  # rebase abort - cancel the rebasing process
  rba = rebase --abort

  # rebase - continue the rebasing process after resolving a conflict manually and updating the index with the resolution.
  rbc = rebase --continue

  # rbi - rebase interactive on our unpushed commits.
  rbi = !"f() { git rebase -i HEAD~"$1"; }; f"

   # Interactively rebase all the commits on the current branch
  rbb = !"git rebase --interactive `git merge-base master HEAD`"

  # See https://blog.filippo.io/git-fixup-amending-an-older-commit/
  # This is a slightly modified version
  fixup = "!f() { TARGET=$(git rev-parse \"$1\"); git commit --fixup=$TARGET && GIT_EDITOR=true git rebase --interactive --autosquash $TARGET~; }; f"

  ### reflog ###

  # reflog - reference log that manages when tips of branches are updated.
  rl = reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)'

  ### remote ###

  # remote commands useful for dealing with untracked branches
  remote-fetch = "!rf() { git config --add remote.origin.fetch +refs/heads/$1:refs/remotes/origin/$1; git fetch origin +$1:refs/remotes/origin/$1; }; rf"
    
  remote-purge = "!rp() { git config --unset remote.origin.fetch \".*$1.*\"; git update-ref -d refs/remotes/origin/$1; }; rp"
  # remote - manage set of tracked repositories [same as "r"].
  rr = remote

  # remote show - gives some information about the remote <name>.
  rrs = remote show

  # remote update - fetch updates for a named set of remotes in the repository as defined by remotes.
  rru = remote update

  # remote prune - deletes all stale remote-tracking branches under <name>.
  rrp = remote prune

  incoming = !git remote update --prune; git log ..@{upstream}
  outgoing = log @{upstream}..

  # Push to all remotes
  push-to-all-remotes = !git remote | xargs -I% -n1 git push %

  ### revert ###

  # revert - undo the changes from some existing commits
  rv = revert

  # revert without autocommit; useful when you're reverting more than one commits' effect to your index in a row.
  rvnc = revert --no-commit

  ### show-branch ###

  # show-branch - print a list of branches and their commits.
  sb = show-branch

  ### submodule ###

  # submodule - enables foreign repositories to be embedded within a dedicated subdirectory of the source tree.
  sm = submodule

  # submodule init
  smi = submodule init

  # submodule add
  sma = submodule add

  # submodule sync
  sms = submodule sync

  # submodule update
  smu = submodule update

  # submodule update with initialize
  smui = submodule update --init

  # submodule update with initialize and recursive; this is useful to bring a submodule fully up to date.
  smuir = submodule update --init --recursive

  ### status ###

  # status with short format instead of full details
  ss = status --short

  # status with short format and showing branch and tracking info.
  ssb = status --short --branch

  ### ALIAS MANAGEMENT ###

  # Show our defined alias list
  aliases = "!git config --get-regexp '^alias\\.' | cut -c 7- | sed 's/ / = /'"

  # From https://gist.github.com/492227
  head = log -n1
  heads = !"git log origin/master.. --format='%Cred%h%Creset;%C(yellow)%an%Creset;%H;%Cblue%f%Creset' | git name-rev --stdin --always --name-only | column -t -s';'"
  lost = !"git fsck | awk '/dangling commit/ {print $3}' | git show --format='SHA1: %C(yellow)%h%Creset %f' --stdin | awk '/SHA1/ {sub(\"SHA1: \", \"\"); print}'"

  ### diff-* ###

  diff-all = !"for name in $(git diff --name-only $1); do git difftool $1 $name & done"
  diff-changes = diff --name-status -r
  diff-stat = diff --stat --ignore-space-change -r
  diff-staged = diff --cached

  # Diff using our preferred options. A.k.a. `dd`.
  diff-deep = diff --check --dirstat --find-copies --find-renames --histogram --color

  ### grep-* ###

  # Find text in any commit ever.
  grep-all = !"f() { git rev-list --all | xargs git grep \"$@\"; }; f"

  # Find text and group the output lines. A.k.a. `gg`.
  grep-group = grep --break --heading --line-number --color

  # grep with ack-like formatting
  grep-ack = \
    -c color.grep.linenumber=\"bold yellow\" \
    -c color.grep.filename=\"bold green\" \
    -c color.grep.match=\"reverse yellow\" \
    grep --break --heading --line-number

  ### init ###

  # initalize a repo and immediate add an empty commit, which makes rebase easier.
  init-empty = !"f() { git init && git commit --allow-empty --allow-empty-message --message ''; }; f"

  
  ### WORKFLOW ALIASES ###

  # Clone a git repository including all submodules
  cloner = clone --recursive

  # Stash aliases for push & pop
  #
  # Note that if you are using an older version of git, before 2.16.0,
  # then you can use the older "stash save" instead of the newer "stash push".
  save = stash push
  pop = stash pop

  # Stash snapshot - from http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
  # Take a snapshot of your current working tree without removing changes.
  # This is handy for refactoring where you can't quite fit what you've done
  # into a commit but daren't stray too far from now without a backup.
  #
  # Running this:
  #
  #    $ git snapshot
  #
  # Creates this stash:
  #
  #    stash@{0}: On feature/handy-git-tricks: snapshot: Mon Apr 8 12:39:06 BST 2013
  #
  # And seemingly no changes to your working tree.
  #
  snapshot = !git stash push "snapshot: $(date)" && git stash apply "stash@{0}"

  # When you're a little worried that the world is coming to an end
  panic = !tar cvf ../panic.tar *

  # Create an archive file of everything in the repo
  archive = !"f() { top=$(rev-parse --show-toplevel); cd $top; tar cvf $top.tar $top ; }; f"

  # Do everything we can to synchronize all changes for the current branch.
  #
  #  * git get: fetch and prune, pull and rebase, then update submodules
  #  * git put: commit all items, then push
  #
  # If you want to preserve merges, then we recommend you set this:
  #
  #     git config pull.rebase preserve
  #
  # TODO: handle tags, delete superfluous branches, and add error handing.
  #
  get = !git fetch --prune && git pull --rebase && git submodule update --init --recursive
  put = !git commit --all && git push

  # Do everything we can to make the local repo like the master branch.
  #
  # TODO: handle tags, and delete superfluous branches, and add error handling.
  #
  mastery = !git checkout master && git fetch origin --prune && git reset --hard origin/master

  # Ignore all untracked files by appending them to .gitignore:
  ignore = "!git status | grep -P \"^\\t\" | grep -vF .gitignore | sed \"s/^\\t//\" >> .gitignore"

  # Do a push/pull for just one branch
  push1 = "!git push origin $(git branch-name)"
  pull1 = "!git pull origin $(git branch-name)"

  # Track and untrack, with default parameters, and with printing the command
  track = "!f(){ branch=$(git rev-parse --abbrev-ref HEAD); cmd=\"git branch $branch -u ${1:-origin}/${2:-$branch}\"; echo $cmd; $cmd; }; f"
  untrack = "!f(){ branch=$(git rev-parse --abbrev-ref HEAD); cmd=\"git branch --unset-upstream ${1:-$branch}\"; echo $cmd; $cmd; }; f"

  # Track all remote branches that aren't already being tracked;
  # this is a bit hacky because of the parsing, and we welcome
  # better code that works using more-specific git commands.
  track-all-remote-branches = !"f() { git branch -r | grep -v ' -> ' | sed 's/^ \\+origin\\///' ; }; f"

  ##
  # Reset & Undo
  ##

  # Reset and undo aliases are ways to move backwards on the commit chain.
  # We find that novices prefer the wording "undo"; experts prefer "reset".
  reset-commit       = reset --soft HEAD~1
  reset-commit-hard  = reset --hard HEAD~1
  reset-commit-clean = !git reset --hard HEAD~1 && git clean -fd
  reset-to-pristine  = !git reset --hard && git clean -ffdx
  reset-to-upstream  = !git reset --hard $(git upstream-name)

  # Undo is simply a synonym for "reset" because "undo" can help novices.
  undo-commit        = reset --soft HEAD~1
  undo-commit-hard   = reset --hard HEAD~1
  undo-commit-clean  = !git reset --hard HEAD~1 && git clean -fd
  undo-to-pristine   = !git reset --hard && git clean -ffdx
  undo-to-upstream   = !git reset --hard $(git upstream-name)

  # Nicknames
  uncommit = reset --soft HEAD~1
  unadd = reset HEAD
  unstage = reset HEAD

  # Discard changes in a (list of) file(s) in working tree
  discard = checkout --

  # Clean and discard changes and untracked files in working tree
  cleanout = !git clean -df && git checkout -- .

  # Work In Progress: from https://gist.github.com/492227 and VonC on stackoverflow.
  # This enables a quick way to add all new and modified files to the index,
  # while cleaning the index from the files removed from the working tree;
  # this cleaning will facilitate a rebase, because there won't be any conflict
  # due to an "unclean" working directory (not in sync with the index).
  # The unwip will restore the deleted files to the working tree.
  wip = !"git add --all; git ls-files --deleted -z | xargs -0 git rm; git commit --message=wip"
  unwip = !"git log -n 1 | grep -q -c wip && git reset HEAD~1"

  # Delete all branches that have already been merged into the master branch.
  master-cleanse = !git master-cleanse-local; git master-cleanse-remote

  # Delete all local branches that have been merged into the local master branch.
  master-cleanse-local = "!git checkout master && git branch --merged | xargs git branch --delete"

  # Delete all remote branches that have been merged into the remote master branch.
  master-cleanse-remote = !"git branch --remotes --merged origin/master | sed 's# *origin/##' | grep -v '^master$' xargs -I% git push origin :% 2>&1 | grep --colour=never 'deleted'"

  # Publish the current branch by pushing it to the remote "origin",
  # and setting the current branch to track the upstream branch.
  publish = !"git push --set-upstream origin $(git branch-name)"

  # Unpublish the current branch by deleting the
  # remote version of the current branch.
  unpublish = !"git push origin :$(git branch-name)"

  # Friendly wording is easier to remember.
  # Thanks to http://gggritso.com/human-git-aliases
  branches = branch -a
  tags = tag -n1 --list
  stashes = stash list


  ### ADVANCED ALIASES ###
  # Prune all your stale remote branches: there's no way to tell
  # git remote update to prune stale branches, and git remote prune
  # does not understand --all. So here is a shell command to do it.
  prune-all = !git remote | xargs -n 1 git remote prune


  ### GitK ###

  # show conflicting merge in gitk:
  gitk-conflict = !gitk --left-right HEAD...MERGE_HEAD

  ### SHELL SCRIPTING ALIASES ###
  # Get the top level directory name
  top-name = rev-parse --show-toplevel
  # Get the current branch name
  branch-name = rev-parse --abbrev-ref HEAD
  # Get the upstream branch name
  upstream-name = !git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)
  # Execute shell scripts. Git always runs scripts in the top directory.
  # For example "git exec pwd" will always show you the top directory.
  exec = ! exec